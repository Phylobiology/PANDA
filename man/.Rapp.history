library(RPANDA)
trees<-TESS::sim.globalBiDe.age(n=20,age=10,0.15,0.05,MRCA=TRUE)
spectR(trees[[1]])
spectR(trees[[2]])
trees[[2]]
trees[[1]]
trees[[3]]
trAll <- lapply(trees[[3]],dist.nodes)
trees[[3]]
tr <- dist.nodes(trees[[3]])
mat <- data.matrix(tr)
gr <- graph.adjacency(mat,weighted=T)
#read libraries#
library(pracma)#
library(diversitree)#
library(RPANDA)#
library(ggplot2)#
library(gridExtra)#
library(DDD)#
library(scatterplot3d)#
library(mclust)#
library(gplots)#
library(fpc)#
library(pvclust)#
library(geiger)#
library(classInt)#
library(TreeSim)#
library(igraph)#!#
#library(Heatplus)#
library(RColorBrewer)#
library(vegan)#
library(cluster)#
library(cladoRcpp)#
library(phylobase)#
library(rexpokit)#
library(optimx)#
library(FD)#
library(xtable)#
library(BioGeoBEARS)#!#
library(clusterSim)#
library(ade4)#
library(TESS)#!#
library(iteRates)#
library(moments)#
library(MCMCpack)#
library(gtools)#
library(FactoMineR)#
library(corrgram)#
#library(rfishbase)#
#data(fishbase)#
#
##gaussian kernel#
sigma = 0.1#
gKernel <- function(x) 1/(sigma*sqrt(2*pi)) * exp(-(x^2)/2*sigma^2)#
kernelG <- function(x, mean=0, sd=1) dnorm(x, mean = mean, sd = sd)#
#
##kernel density estimate#
dens <- function(x, bw = bw.nrd0, kernel = kernelG, n = 4096,#
                from = min(x) - 3*sd, to = max(x) + 3*sd, adjust = 1,#
                ...) {#
  if(has.na <- any(is.na(x))) {#
    x <- na.omit(x)#
    if(length(x) == 0)#
        stop("no finite or non-missing data!")#
  }#
  sd <- (if(is.numeric(bw)) bw[1] else bw(x)) * adjust#
  X <- seq(from, to, len = n)#
  M <- outer(X, x, kernel, sd = sd, ...)#
  structure(list(x = X, y = rowMeans(M), bw = sd,#
                 call = match.call(), n = length(x),#
                 data.name = deparse(substitute(x)),#
                 has.na = has.na), class =  "density")#
}#
#
integr <- function(x, f)#
{#
       # var is numeric#
       if (!is.numeric(x))#
       {#
              stop('The variable of integration "x" is not numeric.')#
       }#
#
       # integrand is numeric#
       if (!is.numeric(f))#
       {#
              stop('The integrand "f" is not numeric.')#
       }#
#
       # length(var)=length(int)#
       if (length(x) != length(f))#
       {#
              stop('The lengths of the variable of integration and the integrand do not match.')#
       }#
#
      # get lengths of var and integrand#
       n = length(x)#
#
       # trapezoidal integration#
       integral = 0.5*sum((x[2:n] - x[1:(n-1)]) * (f[2:n] + f[1:(n-1)]))#
#
       # print definite integral#
       return(integral)#
}#
##compute JSD distance matrix#
dist.JSD <- function(inMatrix, pseudocount=0.000001, ...) {#
	KLD <- function(x,y) sum(x*log(x/y))#
	JSD <- function(x,y) sqrt(0.5*KLD(x,(x+y)/2)+0.5*KLD(y,(x+y)/2))#
	matrixColSize <- length(colnames(inMatrix))#
	matrixRowSize <- length(rownames(inMatrix))#
	colnames <- colnames(inMatrix)#
	resultsMatrix <- matrix(0, matrixColSize, matrixColSize) #
  inMatrix = apply(inMatrix,1:2,function(x) ifelse (x==0,pseudocount,x))#
	for(i in 1:matrixColSize) {#
		for(j in 1:matrixColSize) { #
			resultsMatrix[i,j]=JSD(as.vector(inMatrix[,i]),#
			as.vector(inMatrix[,j]))#
		}#
	}#
	colnames -> colnames(resultsMatrix) -> rownames(resultsMatrix)#
	as.dist(resultsMatrix)->resultsMatrix#
	attr(resultsMatrix, "method") <- "dist"#
	return(resultsMatrix) #
 }#
#
JSDist <- function(x,y) sqrt(dist.JSD(x,y))#
##find number of clusters, cluster data#
pam.clustering=function(x,k) { # x=dist matrix, k= No. clusters#
require(cluster)#
      cluster = as.vector(pam(as.dist(x), k, diss=TRUE)$clustering)#
            return(cluster)#
                        }#
#simulate random matrices for non-tree JS distances#
makeMat = function(x) {#
    set.seed(2718)#
    mat = matrix(ncol=x, nrow=x)#
    for (i in 1:x) {#
        mat[, i] = rnorm(x)#
    }#
    return(mat)#
}#
#
##kurtosis#
kurtosis.sub <-#
    function (x, na.rm = FALSE, method = c("excess","moment", "fisher"), ...)#
{#
    method = match.arg(method)#
#
    stopifnot(NCOL(x) == 1)#
#
    # Warnings:#
    if (!is.numeric(x) && !is.complex(x) && !is.logical(x)) {#
        warning("argument is not numeric or logical: returning NA")#
        return(as.numeric(NA))}#
#
    # Remove NAs:#
    if (na.rm) x = x[!is.na(x)]#
#
    # Kurtosis:#
    n = length(x)#
    if (is.integer(x)) x = as.numeric(x)#
    if (method == "moment") {#
        kurtosis = sum((x-mean(x))^4/as.numeric(var(x))^2)/length(x)#
    }#
     if (method == "excess") {#
        kurtosis = sum((x-mean(x))^4/var(x)^2)/length(x) - 3#
    }#
#
    if (method == "fisher") {#
        kurtosis = ((n+1)*(n-1)*((sum(x^4)/n)/(sum(x^2)/n)^2 -#
            (3*(n-1))/(n+1)))/((n-2)*(n-3))#
    }#
#
    # Return Value:#
    kurtosis#
}#
#plot gaussian#
#gaussX   <- seq(5,15,length=1000)#
#gaussY   <- dnorm(gaussX,mean=10, sd=3)#
#gau <- plot(gaussX,gaussY, type="l", lwd=1)#
#
`%ni%` <- Negate(`%in%`)#
drop.tip.ni <- function(phy, tip, trim.internal = TRUE, subtree = FALSE,#
         root.edge = 0, rooted = is.rooted(phy)) {#
  Ntip <- length(phy$tip.label)#
  if (is.character(tip)) #
    tip <- which(phy$tip.label %ni% tip)#
#
  phy <- reorder(phy)#
  NEWROOT <- ROOT <- Ntip + 1#
  Nnode <- phy$Nnode#
  Nedge <- nrow(phy$edge)#
#
  wbl <- !is.null(phy$edge.length)#
  edge1 <- phy$edge[, 1]#
  edge2 <- phy$edge[, 2]#
  keep <- !(edge2 %in% tip)  #
#
  ints <- edge2 > Ntip#
  repeat {#
    sel <- !(edge2 %in% edge1[keep]) & ints & keep#
    if (!sum(sel)) #
      break#
    keep[sel] <- FALSE#
  }#
#
  phy2 <- phy#
  phy2$edge <- phy2$edge[keep, ]#
  if (wbl) #
    phy2$edge.length <- phy2$edge.length[keep]#
  TERMS <- !(phy2$edge[, 2] %in% phy2$edge[, 1])#
  oldNo.ofNewTips <- phy2$edge[TERMS, 2]#
  n <- length(oldNo.ofNewTips)#
  idx.old <- phy2$edge[TERMS, 2]#
  phy2$edge[TERMS, 2] <- rank(phy2$edge[TERMS, 2])#
  phy2$tip.label <- phy2$tip.label[-tip]#
  if (!is.null(phy2$node.label))#
    phy2$node.label <-#
      phy2$node.label[sort(unique(phy2$edge[, 1])) - Ntip]#
  phy2$Nnode <- nrow(phy2$edge) - n + 1L#
  i <- phy2$edge > n#
  phy2$edge[i] <- match(phy2$edge[i], sort(unique(phy2$edge[i]))) + n#
  storage.mode(phy2$edge) <- "integer"#
  collapse.singles(phy2)#
}#
#
cbind.fill<-function(...){#
    nm <- list(...) #
    nm <-lapply(nm, as.matrix)#
    n <- max(sapply(nm, nrow)) #
    do.call(cbind, lapply(nm, function (x) #
    rbind(x, matrix(, n-nrow(x), ncol(x))))) #
}#
#
#colless#
collessit <- function(x, metric = "colless") {#
    if (metric == "colless") {#
        xx <- as.treeshape(x)  # convert to apTreeshape format#
        colless(xx, "yule")  # calculate colless' metric#
    } else if (metric == "gamma") {#
        gammaStat(x)#
    } else stop("metric should be one of colless or gamma")#
}#
#
#kmeansBIC#
kmeansBIC = function(fit){#
#
m = ncol(fit$centers)#
n = length(fit$cluster)#
k = nrow(fit$centers)#
D = fit$tot.withinss#
return(data.frame(BIC = D + log(n)*m*k))#
}#
#
##set colors#
red=rgb(255, 0, 0, 100, names = NULL, maxColorValue = 255)#
green=rgb(0,255, 0, 100, names = NULL, maxColorValue = 255)#
blue=rgb(0, 0, 255, 100, names = NULL, maxColorValue = 255)#
yellow=rgb(255,255, 0, 100, names = NULL, maxColorValue = 255)#
cyan=rgb(50, 255, 255, 100, names = NULL, maxColorValue = 255)#
purple=rgb(255, 0, 255, 100, names = NULL, maxColorValue = 255) #
gray=rgb(100,100, 200, 100, names = NULL, maxColorValue = 255)
gr <- graph.adjacency(mat,weighted=T)
gr
lap <- graph.laplacian(gr,normalized=F)
lap
trees[[3]][1]
trees[[3]][2]
5.083109 + 3.259200 + 1.657691 + 1.657691 + 4.916891+ 10.000000
plot(trees[[3]])
3.315382  +9.833782 +20.00000 +10.000000  +4.916891
5.083109 + 3.259200 + 1.657691
48.06605+1.657691
20+20+20+10+15.08+18.34
